name: Deploy Lure Application to Server

on:
  # Dispara o workflow em push para a branch 'refact/nginx'.
  # IMPORTANTE: Altere 'refact/nginx' para a sua branch principal de deploy (ex: 'main' ou 'pipeline') quando estiver pronto.
  push:
    branches: [ "refact/nginx" ]

  # Permite que você rode este workflow manualmente pela aba Actions
  workflow_dispatch:

jobs:
  deploy:
    name: Build and Deploy Application
    runs-on: self-hosted # Este job roda diretamente no seu servidor

    steps:
      # PASSO CORRIGIDO: Usando um comando 'find' mais seguro para limpar o diretório.
      # Isso evita o erro 'rm: can't remove . or ..'
      - name: Force Clean Workspace
        run: docker run --rm -v ${{ github.workspace }}:/workspace alpine sh -c "find /workspace/. -mindepth 1 -delete"

      # Passo 1: Baixar o código mais recente do repositório
      - name: Check out repository
        uses: actions/checkout@v4

      # Passo 2: Criar o arquivo .env no servidor usando os valores fornecidos.
      # O comando 'cat << EOF > .env' é uma forma eficiente de criar um arquivo com múltiplas linhas.
      - name: Diagnose Port 80 Usage (No Sudo)
        run: |
          echo "--- Checking for processes on port 80 (without sudo) ---"
          lsof -i :80 || echo "lsof command failed or port 80 is free. This is expected if the process is not owned by the current user."
          echo "--- Listing running Docker containers using port 80 ---"
          docker ps --filter "publish=80"
          echo "--- Checking for common web server processes ---"
          ps aux | grep -E '[n]ginx|[a]pache|[h]ttpd' || echo "No other common web server processes found."
          echo "--- End of diagnosis ---"
        continue-on-error: true

      - name: Create .env file
        run: |
          cat << EOF > .env
          FLASK_APP=app.py
          FLASK_ENV=production
          FLASK_PORT=5000
          JWT_SECRET_KEY=065997468111a63c1a6927b1875dc5334fce64729c038800baa5464a2b4e2a7b
          JWT_EXPIRATION_MINUTES=1440
          PYTHONPATH=/:/api
          DB_HOST=lure_mysql_srvr
          DB_PORT=3306
          DB_DATABASE=Lure
          DB_USERNAME=65CC63A4E10EE8F05BE4E1A8
          DB_PASSWORD=1C969B094797CB3AF27FF949
          MYSQL_HOST=lure_mysql_srvr
          MYSQL_PORT=3306
          MYSQL_ROOT_PASSWORD=1C969B094797CB3AF27FF949
          MYSQL_DATABASE=Lure
          MYSQL_USER=65CC63A4E10EE8F05BE4E1A8
          MYSQL_PASSWORD=1C969B094797CB3AF27FF949
          REDIS_HOST=lure_redis_srvr
          REDIS_PORT=6379
          REDIS_PASSWORD=redis_password
          REDIS_DB=0
          EOF

      # NOVO PASSO DE DIAGNÓSTICO:
      # Este comando vai mostrar o que o docker-compose está lendo.
      - name: Validate and Display Docker-Compose Configuration
        run: docker-compose config

      # Passo 3: Parar, reconstruir e iniciar a aplicação.
      # Agora o docker-compose encontrará o .env e funcionará corretamente.
      - name: Stop, Rebuild, and Deploy Docker Stack
        run: |
          echo "--- Tearing down existing services ---"
          docker-compose down || true
          echo "--- Building all images without cache ---"
          docker-compose build --no-cache
          echo "--- Starting all services ---"
          docker-compose up -d
          echo "--- Waiting for services to be healthy ---"
          sleep 30
          docker-compose ps

      # Passo 4: Verificar se os serviços estão funcionando
      - name: Verify Services Health
        run: |
          echo "--- Checking container status ---"
          docker-compose ps
          echo "--- Testing API health endpoint ---"
          curl -f http://localhost:8080/api/health || echo "API health check failed"
          echo "--- Testing nginx health endpoint ---"
          curl -f http://localhost:8080/nginx-health || echo "Nginx health check failed"
          echo "--- Showing service logs (last 20 lines) ---"
          docker-compose logs --tail=20
        continue-on-error: true

      - name: Clean up old Docker images
        run: docker image prune -f
